# Реализация каскадных изменений в базе данных

Для реализации каскадных изменений в базе данных, когда какой-либо источник помечается как `is_deleted = 1`, и все связанные с ним данные должны быть также помечены как неактуальные (`is_deleted = 1`), можно использовать триггеры базы данных или выполнить каскадное обновление с использованием SQLAlchemy.

### Использование триггеров базы данных

Создание триггеров в базе данных является более низкоуровневым и автоматическим подходом, который не требует изменений в приложении после его настройки. Вот пример создания триггера в MySQL, который будет автоматически обновлять флаг `is_deleted` для связанных записей в таблицах `fact` и `fact_detail`, когда запись в таблице `source` обновляется:

```sql
DELIMITER //

CREATE TRIGGER source_delete_cascade
AFTER UPDATE ON source
FOR EACH ROW
BEGIN
    IF NEW.is_deleted = 1 THEN
        UPDATE fact
        SET is_deleted = 1
        WHERE source_ID = NEW.source_ID;
        
        UPDATE fact_detail
        SET is_deleted = 1
        WHERE fact_ID IN (
            SELECT fact_ID
            FROM fact
            WHERE source_ID = NEW.source_ID
        );
    END IF;
END;
//

DELIMITER ;
```

### Использование SQLAlchemy

Если вы предпочитаете использовать Python и SQLAlchemy для каскадного обновления, можно написать функцию, которая будет обрабатывать это. Вот пример такого подхода:

```python
from sqlalchemy import create_engine, update
from sqlalchemy.orm import sessionmaker
from model import Base, Source, Fact, FactDetail
from main import session

def mark_source_and_related_deleted(source_id):
    # Пометить источник как удаленный
    session.query(Source).filter(Source.source_ID == source_id).update({"is_deleted": True})
    
    # Найти все факты, связанные с источником
    facts = session.query(Fact).filter(Fact.source_ID == source_id).all()
    
    # Пометить все факты как удаленные
    for fact in facts:
        session.query(Fact).filter(Fact.fact_ID == fact.fact_ID).update({"is_deleted": True})
        # Пометить все детали фактов как удаленные
        session.query(FactDetail).filter(FactDetail.fact_ID == fact.fact_ID).update({"is_deleted": True})
    
    session.commit()

# Пример использования функции
mark_source_and_related_deleted(1)
```

### Объяснение кода

1. **Триггер**:
    - Триггер `source_delete_cascade` создается для таблицы `source` и срабатывает после обновления записи.
    - Если запись в таблице `source` помечена как `is_deleted = 1`, триггер обновляет все связанные записи в таблицах `fact` и `fact_detail`, помечая их также как `is_deleted = 1`.

2. **SQLAlchemy**:
    - Функция `mark_source_and_related_deleted` принимает `source_id` и обновляет флаг `is_deleted` для указанного источника и всех связанных записей в таблицах `fact` и `fact_detail`.
    - Сначала обновляется запись в таблице `source`.
    - Затем выбираются все связанные факты, и для каждого факта обновляется флаг `is_deleted`.
    - Далее обновляются все детали фактов, связанные с каждым фактом.

Оба подхода имеют свои преимущества: триггеры обеспечивают автоматическое каскадное обновление на уровне базы данных, тогда как использование SQLAlchemy позволяет управлять процессом каскадного обновления на уровне приложения и обеспечивает более гибкое управление. Выбор подхода зависит от ваших предпочтений и требований проекта.

### Преимущества триггеров в базе данных

1. **Автоматичность**:
   - Триггеры автоматически срабатывают при определенных событиях (например, обновление записи), что устраняет необходимость дополнительного программирования или вызова функций на уровне приложения.

2. **Централизованная логика**:
   - Логика обработки данных сосредоточена в базе данных, что может упростить управление и поддержку, особенно в системах с несколькими клиентскими приложениями.

3. **Независимость от приложения**:
   - Логика выполнения триггеров не зависит от используемого языка программирования или ORM. Она работает одинаково для всех приложений, взаимодействующих с базой данных.

4. **Повышение целостности данных**:
   - Триггеры обеспечивают поддержание целостности данных на уровне базы данных, что помогает предотвратить ошибки и неконсистентность данных.

### Недостатки триггеров в базе данных

1. **Сложность отладки и тестирования**:
   - Триггеры могут быть сложны для отладки, поскольку они срабатывают автоматически и могут быть неочевидны при выполнении операций с базой данных.

2. **Производительность**:
   - Триггеры могут влиять на производительность базы данных, особенно если они выполняют сложные операции или если операции обновления выполняются часто.

3. **Сложность управления**:
   - Управление и поддержка триггеров могут быть сложными, особенно в больших и сложных системах с множеством триггеров и зависимостей между ними.

### Преимущества SQLAlchemy и каскадного обновления на уровне приложения

1. **Простота отладки и тестирования**:
   - Логику обработки данных на уровне приложения легче отлаживать и тестировать с использованием стандартных инструментов и методов отладки.

2. **Гибкость**:
   - Вы можете легко изменять и расширять логику каскадного обновления в коде приложения, не затрагивая структуру базы данных.

3. **Контроль над производительностью**:
   - Логика каскадного обновления может быть оптимизирована на уровне приложения, что может помочь снизить нагрузку на базу данных.

4. **Логическая изоляция**:
   - Каскадные операции могут быть выполнены в контексте бизнес-логики приложения, что может быть более естественным и понятным для разработчиков.

### Недостатки SQLAlchemy и каскадного обновления на уровне приложения

1. **Необходимость вызова функций**:
   - Каскадное обновление должно быть явно вызвано в коде приложения, что увеличивает вероятность ошибок и пропущенных обновлений.

2. **Повышенная сложность приложения**:
   - Логика каскадного обновления увеличивает сложность кода приложения, что может затруднить его поддержку и развитие.

3. **Зависимость от ORM**:
   - Логика обработки данных зависит от используемого ORM, что может затруднить переносимость кода между разными системами или базами данных.

### Выбор подхода

Выбор между использованием триггеров в базе данных и реализацией логики каскадного обновления на уровне приложения зависит от конкретных требований и архитектуры вашей системы:

- **Используйте триггеры**: если вам нужна автоматическая и централизованная логика каскадного обновления, которая работает независимо от приложений, и вы готовы пожертвовать сложностью управления триггерами.
- **Используйте SQLAlchemy**: если вам нужна гибкость, простота отладки и тестирования, а также контроль над производительностью на уровне приложения, и вы можете обеспечить явный вызов логики каскадного обновления в вашем коде.
